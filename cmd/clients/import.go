/*
 * Copyright Â© 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 */

package clients

import (
	"encoding/json"
	"fmt"
	"github.com/ory/hydra/cmd/cli"
	"github.com/ory/hydra/internal/httpclient/client/admin"
	"github.com/ory/hydra/internal/httpclient/models"
	"github.com/ory/x/cmdx"
	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	"os"
)

func newImportCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "import <path/to/file.json> [<path/to/other/file.json>...]",
		Short: "Import OAuth 2.0 Clients from one or more JSON files",
		Args:  cobra.MinimumNArgs(1),
		Long: fmt.Sprintf(`This command reads in each listed JSON file and imports their contents as OAuth 2.0 Clients.

The format of the JSON file is:

{
  "client_id": "...",
  "client_secret": "...",
  // ... all other fields of the OAuth 2.0 Client model are allowed here
}

Use "hydra clients valdiate <file.json>" to validate the client file locally.

Please be aware that this command does not update existing clients. If the client exists already, this command will fail.

%s
`, autoGeneratedSecretDescription),
		Example: `$ hydra clients import client-1.json
$ hydra clients import client-2.json --keybase keybase_username`,
		RunE: importClient,
	}

	cli.RegisterSecretEncryptionFlags(cmd.LocalFlags())

	return cmd
}

func importClient(cmd *cobra.Command, args []string) error {
	m := cli.ConfigureClient(cmd)

	encryptSecret, err := cli.NewEncryptionFunc(cmd, nil)
	if err != nil {
		return err
	}

	imported := make(outputOAuth2ClientCollection, 0, len(args))
	failed := make(map[string]error)

	for _, path := range args {
		reader, err := os.Open(path)
		if err != nil {
			failed[path] = errors.Wrap(err, "could not open the file")
			continue
		}

		var c models.OAuth2Client
		if err := json.NewDecoder(reader).Decode(&c); err != nil {
			failed[path] = errors.Wrap(err, "could not parse JSON")
			continue
		}

		response, err := m.Admin.CreateOAuth2Client(admin.NewCreateOAuth2ClientParams().WithBody(&c))
		if err != nil {
			failed[path] = err
			continue
		}

		result := response.Payload

		if c.ClientSecret == "" {
			enc, err := encryptSecret(result.ClientSecret)
			if err != nil {
				_, _ = fmt.Fprintf(cmd.ErrOrStderr(), "Failed to encrypt client secret for %s: %s\n", result.ClientID, err)
			} else {
				result.ClientSecret = enc
			}
		}

		imported = append(imported, result)
	}

	if len(imported) == 1 {
		cmdx.PrintRow(cmd, (*outputOAuth2Client)(imported[0]))
	} else {
		cmdx.PrintCollection(cmd, imported)
	}

	if len(failed) != 0 {
		cmdx.PrintErrors(cmd, failed)
		return cmdx.FailSilently(cmd)
	}
	return nil
}
